## Thread

JAVA에서 Thread 구현 방법은 **Runnable 객체를 이용**하는 방법과 **Thread를 상속** 받는 방법이 있다.

Runnable 객체를 이용하는 방법은 다중 상속의 문제를 해결하기 위해 사용된다.

### 1. Runnable 객체를 이용

#### 1.1 클래스로 구현

```java
Thread thread = new Thread(Runnable target);
```

```java
public class Task implements Runnable{
    @Override
    public void run(){
        // 쓰레드에서 처리할 로직
    }
}
```

```java
Runnable task = new Task();
Thread thread = new Thread(task);
```

##### 예제

```java
package com.jremind.thread;

public class FlaskTask implements Runnable{

	@Override
	public void run() {
		for(int i=0; i<10; i++) {
			System.out.println("청기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```

```java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		Runnable flagTask = new FlagTask();
		Thread thread = new Thread(flagTask);
		thread.start();
		
		
		for(int i=0; i<10; i++) {
			System.out.println("백기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}

	}

}
```

#### 1.2 익명 구현 객체

```java
Thread thread = new Thread(new Runnable()){
    @Override
    public void run(){
        //쓰레드에서 처리할 로직
    }
}
```

##### 예제

```java
package com.jremind.thread;

public class ThreadExam02 {
	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			@Override
			public void run() {
				for(int i=0; i<10; i++) {
					System.out.println("청기");
					try {
						Thread.sleep(500);
					}catch(Exception e) {}
				}
			}
		});
		thread.start();
		
		for(int i=0; i<10; i++) {
			System.out.println("백기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```

#### 1.3 람다식 이용

```java
Thread thread = new Thread((...)->{...})
```

```java
package com.jremind.thread;

public class ThreadExam03 {
	public static void main(String[] args) {
		Thread thread = new Thread(() -> {
			for(int i=0; i<10; i++) {
				System.out.println("청기");
				try {
					Thread.sleep(500);
				}catch(Exception e) {}
			}
		});
		thread.start();
		
		for(int i=0; i<10; i++) {
			System.out.println("백기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```



### 2. Thread를 상속 받는 방법

#### 2.1 클래스로 구현

```java
public class WorkerThread extends Thread{
    @Override
    public void run(){
        
    }
}

Thread thread = new WorkerThread();
thread.start()
```

##### 예제

```java
// FlagTHread.java
package com.jremind.thread;

public class FlagThread extends Thread{

	@Override
	public void run() {
		for(int i=0; i<10; i++) {
			System.out.println("청기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```

```java
// ThreadExam01.java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		Thread thread = new FlagThread();
		thread.start();
		
		for(int i=0; i<10; i++) {
			System.out.println("백기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```

#### 2.2 익명 구현 자식 객체 구현

```java
package com.jremind.thread;

public class ThreadExam02 {
	public static void main(String[] args) {
		Thread thread = new Thread(){
			@Override
			public void run() {
				for(int i=0; i<10; i++) {
					System.out.println("청기");
					try {
						Thread.sleep(500);
					}catch(Exception e) {}
				}
			}
		};
		thread.start();
        
		for(int i=0; i<10; i++) {
			System.out.println("백기");
			try {
				Thread.sleep(500);
			}catch(Exception e) {}
		}
	}
}
```





### Thread name

```java
package com.jremind.thread;

public class ThreadA extends Thread{
	public ThreadA() {
		setName("ThreadA");
	}
	
	public void run() {
		for(int i=0; i<2; i++) {
			System.out.println(getName() + "- 출력");
		}
	}
}
```

```java
package com.jremind.thread;

public class ThreadB extends Thread{

	@Override
	public void run() {
		for(int i = 0; i<2; i++) {
			System.out.println(getName() + "- 출력");
		}
	}
}

```

```java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		Thread mainThread = Thread.currentThread();
		System.out.println("프로그램 시작 쓰레드 이름: " + mainThread.getName());
		
		ThreadA threadA = new ThreadA();
		System.out.println("작업 쓰레드 이름: " + threadA.getName());
		threadA.start();
		
		ThreadB threadB = new ThreadB();
		System.out.println("작업 쓰레드 이름: " + threadB.getName());
		threadB.start();
	}
}
```

```shell
# 결과
프로그램 시작 쓰레드 이름: main
작업 쓰레드 이름: ThreadA
ThreadA- 출력
작업 쓰레드 이름: Thread-1
ThreadA- 출력
Thread-1- 출력
Thread-1- 출력
```





### Thread 임계영역(Critical Section)

임계영역은 **둘 이상의 쓰레드가 동시에 한개의 연산을 동시에 실행할 경우 발생할 수 있는 코드 블록이다.**

예를 들어, 사용자1과 사용자2가 계산기를 사용하는데 사용자1은 메모리를 100으로 사용자2는 메모리를 50으로 동시에 실행할 경우 의도하지 않는 결과를 얻을 수 있다.

```java
// Calculator.java
package com.jremind.thread;

public class Calculator {
	private int memory;
	
	public int getMemory() {
		return memory;
	}
	
	public void setMemory(int memory) {
		this.memory = memory;
		try {
			Thread.sleep(2000);
		}catch (InterruptedException e) {
			
		}
		System.out.println(Thread.currentThread().getName() + ": " + this.memory);
	}
}
```

```java
// User1.java
package com.jremind.thread;

public class User1 extends Thread{
	private Calculator calculator;
	
	public void setCalculator(Calculator calculator) {
		this.calculator = calculator;
		this.setName("User1");
	}
	
	@Override
	public void run() {
		calculator.setMemory(100);
	}
}
```

```java
// User2.java
package com.jremind.thread;

public class User2 extends Thread{
	private Calculator calculator;
	
	public void setCalculator(Calculator calculator) {
		this.calculator = calculator;
		this.setName("User2");
	}
	
	@Override
	public void run() {
		calculator.setMemory(50);
	}
}
```

```java
// ThreadExam01.java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		Calculator calculator = new Calculator();
		
		User1 user1 = new User1();
		user1.setCalculator(calculator);
		user1.start();
		
		User2 user2 = new User2();
		user2.setCalculator(calculator);
		user2.start();
	}
}
```

```shell
# 결과
User1: 50
User2: 50
```



이러한 문제를 해결하기 위해 필요한 것이 **동기화**이다. 동기화를 해주기 위해 synchronized를 사용한다.

```java
// Calculator.java
package com.jremind.thread;

public class Calculator {
	private int memory;
	
	public int getMemory() {
		return memory;
	}
	
	public synchronized void setMemory(int memory) {
		this.memory = memory;
		try {
			Thread.sleep(2000);
		}catch (InterruptedException e) {
			
		}
		System.out.println(Thread.currentThread().getName() + ": " + this.memory);
	}
}
```

method에 synchronized를 사용하지 않고 실제고 동기화 부분이 필요한 부분만 synchronized를 할 수 있다.

```java
// Calculator.java
package com.jremind.thread;

public class Calculator {
	private int memory;
	
	public int getMemory() {
		return memory;
	}
	
	public void setMemory(int memory) {
		synchronized (this) {
			this.memory = memory;
			try {
				Thread.sleep(2000);
			}catch (InterruptedException e) {
				
			}
			System.out.println(Thread.currentThread().getName() + ": " + this.memory);
		}
	}
}

```

### Thread 종료

#### 종료 방법 1

```java
// PrintThread1.java
package com.jremind.thread;

public class PrintThread1 extends Thread{
	private boolean stop;
	
	public void setStop(boolean stop) {
		this.stop = stop;
	}

	@Override
	public void run() {
		while(!stop) {
			System.out.println("실행 중");
		}
		System.out.println("사용하던 자원 정리");
		System.out.println("실행 종료");
	}
}
```

```java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		PrintThread1 printThread = new PrintThread1();
		
		printThread.start();
		
		try {
			Thread.sleep(1000);
		}catch (InterruptedException e) {}
		
		printThread.setStop(true);
	}
}
```

#### 종료 방법2 (interrupt)

**interrupt**를 사용하기 위해서는 **Thread가 일시 정지 상태**가 되어야 한다. 예제에서는 일시 정지 상태를 만들기 위해서 sleep(1)을 사용했다.

```java
// printThread2.java
public class printThread2 extends Thread{

	@Override
	public void run() {
		try {
			while(true) {
				System.out.println("실행 중");
				Thread.sleep(1);
			}
		}catch (InterruptedException e) {}
		
		System.out.println("사용하던 자원 정리");
		System.out.println("실행 종료");
	}
}

```

```java
// ThreadExam01.java
public class ThreadExam01 {
	public static void main(String[] args) {
		Thread thread = new printThread2();
		thread.start();
		
		try {
			Thread.sleep(1000);
		}catch (InterruptedException e) {}
		
		thread.interrupt();
	}
}
```

**interrupted()** 메서드를 사용하여 interrupt가 요청 되었는지 확인 하는 방법도 있다.

```java
// printThread3.java
package com.jremind.thread;

public class printThread3 extends Thread{
	@Override
	public void run() {		
		while(true) {
			System.out.println("실행 중");
			if(Thread.interrupted())
				break;			
		}
		System.out.println("사용하던 자원 정리");
		System.out.println("실행 종료");
	}
}
```

### 데몬 쓰레드

```java
package com.jremind.thread;

public class AutoSaveThread extends Thread{
	
	@Override
	public void run() {
		while(true) {
			System.out.println("자동 저장 되었습니다.!");
			try {
				Thread.sleep(1000);
			}catch (InterruptedException e) {}
		}
	}
}
```

```java
package com.jremind.thread;

public class ThreadExam01 {
	public static void main(String[] args) {
		AutoSaveThread thread = new AutoSaveThread();
		thread.setDaemon(true);
		thread.start();
		try {
			Thread.sleep(10000);
		}catch(InterruptedException e) {}
	}
}
```

